<!--
参考：https://threejs.org/manual/#zh/optimize-lots-of-objects
-->
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>大量对象的优化</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        html, body {
            height: 100%;
            margin: 0;
        }
        #c {
            width: 100%;
            height: 100%;
            display: block;
        }
    </style>
    <!-- <script type="text/javascript" src="js/three.min.js"></script> -->
</head>
<body>
<div id="wrap">
    <canvas id="c"></canvas>
</div>

<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
<script type="importmap">
			{
				"imports": {
					"three": "./build/three.module.js"
				}
			}
</script>
<script type="module">
    import * as THREE from 'three';
    import {GUI} from './js/lil-gui.module.min.js';
    import {OrbitControls} from './jsm/controls/OrbitControls.js'; // 允许相机环绕目标的控制器

    function main() {
        const canvas = document.querySelector('#c');
        const renderer = new THREE.WebGLRenderer({canvas});

        const fov = 60;
        const aspect = 2;  // the canvas default
        const near = 0.1;
        const far = 10;
        const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
        camera.position.z = 2.5;

        const controls = new OrbitControls(camera, canvas);
        controls.enableDamping = true;
        controls.enablePan = false;
        controls.minDistance = 1.2;
        controls.maxDistance = 4;
        controls.update();

        const scene = new THREE.Scene();
        scene.background = new THREE.Color('black');

        {
            const loader = new THREE.TextureLoader();
            const texture = loader.load('./resources/images/world.jpg', render);
            const geometry = new THREE.SphereGeometry(1, 64, 32);
            const material = new THREE.MeshBasicMaterial({map: texture});
            scene.add(new THREE.Mesh(geometry, material));
        }

        async function loadFile(url) {
            const req = await fetch(url);
            return req.text();
        }

//        写几行数据来解析文件内容
        // 上面的代码返回了一个有着全部键值对的对象, 然后data属性是网格化的数据. min 和 max 中是 data 中的极值
        function parseData(text) {
            const data = [];
            const settings = {data};
            let max;
            let min;
            // split into lines
            text.split('\n').forEach((line) => {
                // split the line by whitespace
                const parts = line.trim().split(/\s+/);
                if (parts.length === 2) {
                    // only 2 parts, must be a key/value pair
                    settings[parts[0]] = parseFloat(parts[1]);
                } else if (parts.length > 2) {
                    // more than 2 parts, must be data
                    const values = parts.map((v) => {
                        const value = parseFloat(v);
                        if (value === settings.NODATA_value) {
                            return undefined;
                        }
                        max = Math.max(max === undefined ? value : max, value);
                        min = Math.min(min === undefined ? value : min, value);
                        return value;
                    });
                    data.push(values);
                }
            });
            return Object.assign(settings, {min, max});
        }

//        绘图函数
        function addBoxes(file) {
            const {min, max, data} = file;
            const range = max - min;

            // make one box geometry
            const boxWidth = 1;
            const boxHeight = 1;
            const boxDepth = 1;
            const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);
            // make it so it scales away from the positive Z axis
            geometry.applyMatrix4(new THREE.Matrix4().makeTranslation(0, 0, 0.5));

            // these helpers will make it easy to position the boxes
            // We can rotate the lon helper on its Y axis to the longitude
            const lonHelper = new THREE.Object3D();
            scene.add(lonHelper);
            // We rotate the latHelper on its X axis to the latitude
            const latHelper = new THREE.Object3D();
            lonHelper.add(latHelper);
            // The position helper moves the object to the edge of the sphere
            const positionHelper = new THREE.Object3D();
            positionHelper.position.z = 1;
            latHelper.add(positionHelper);

            const lonFudge = Math.PI * .5;
            const latFudge = Math.PI * -0.135;
            data.forEach((row, latNdx) => {
                row.forEach((value, lonNdx) => {
                    if (value === undefined) {
                        return;
                    }
                    const amount = (value - min) / range;
                    const material = new THREE.MeshBasicMaterial();
                    const hue = THREE.MathUtils.lerp(0.7, 0.3, amount);
                    const saturation = 1;
                    const lightness = THREE.MathUtils.lerp(0.4, 1.0, amount);
                    material.color.setHSL(hue, saturation, lightness);
                    const mesh = new THREE.Mesh(geometry, material);
                    scene.add(mesh);

                    // adjust the helpers to point to the latitude and longitude
                    lonHelper.rotation.y = THREE.MathUtils.degToRad(lonNdx + file.xllcorner) + lonFudge;
                    latHelper.rotation.x = THREE.MathUtils.degToRad(latNdx + file.yllcorner) + latFudge;

                    // use the world matrix of the position helper to
                    // position this mesh.
                    positionHelper.updateWorldMatrix(true, false);
                    mesh.applyMatrix4(positionHelper.matrixWorld);

                    mesh.scale.set(0.005, 0.005, THREE.MathUtils.lerp(0.01, 0.5, amount));
                });
            });
        }

        // ASC文件是加密软件PGP（Pretty Good Privacy）使用的加密文件 -
        // 它包含经过数字签名的消息，并且可以存储纯文本书面信息以及编码为文本的二进制信息。ASC文件还包含一个密钥，可以使用PGP身份验证方法进行验证。
        loadFile('./resources/data/gpw/gpw_v4_basic_demographic_characteristics_rev10_a000_014mt_2010_cntm_1_deg.asc')
            .then(parseData)
            .then(addBoxes)
            .then(render);

        // 下面的代码是按需渲染和reseize时的处理
        function resizeRendererToDisplaySize(renderer) {
            const canvas = renderer.domElement;
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            const needResize = canvas.width !== width || canvas.height !== height;
            if (needResize) {
                renderer.setSize(width, height, false);
            }
            return needResize;
        }

        let renderRequested = false;

        function render() {
            renderRequested = undefined;

            if (resizeRendererToDisplaySize(renderer)) {
                const canvas = renderer.domElement;
                camera.aspect = canvas.clientWidth / canvas.clientHeight;
                camera.updateProjectionMatrix();
            }

            controls.update();
            renderer.render(scene, camera);
        }
        render();

        function requestRenderIfNotRequested() {
            if (!renderRequested) {
                renderRequested = true;
                requestAnimationFrame(render);
            }
        }

        controls.addEventListener('change', requestRenderIfNotRequested);
        window.addEventListener('resize', requestRenderIfNotRequested);
    }

    main();

</script>
</body>
</html>
